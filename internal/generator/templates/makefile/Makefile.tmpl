.PHONY: help deps build build-cli run test deploy deploy-local clean{{- if .HasGRPC}} generate{{- end}}{{- if .HasDynamoDB}} terraform terraform-init terraform-plan terraform-apply{{- end}}{{- if .HasPostgres}} atlas-init migrate migrate-up migrate-down migrate-status migrate-new migrate-prod migrate-validate migrate-lint atlas-check{{- end}}

# Default target
help:
	@echo "Available commands:"
	@echo "  deps         - Install all dependencies"
	@echo "  build        - Build the API server"
	@echo "  build-cli    - Build the postctl CLI"
	@echo "  install-cli  - Install postctl to /usr/local/bin"
	@echo "  run          - Run the application"
	@echo "  test         - Run tests"
{{- if .HasGRPC}}
	@echo "  generate     - Generate code from protobuf definitions"
{{- end}}
{{- if .HasDynamoDB}}
	@echo "  terraform    - Provision infrastructure with Terraform"
{{- end}}
{{- if .HasPostgres}}
	@echo "  atlas-init   - Initialize Atlas project (run once)"
	@echo "  migrate      - Apply migrations to local database"
	@echo "  migrate-up   - Apply migrations to local database"
	@echo "  migrate-down - Rollback last migration"
	@echo "  migrate-status - Check migration status"
	@echo "  migrate-new  - Create a new migration"
	@echo "  migrate-prod - Apply migrations to production"
	@echo "  migrate-validate - Validate migrations"
	@echo "  migrate-lint - Lint migrations"
{{- end}}
	@echo "  deploy       - Deploy to Fly.io (creates app on first run, provisions infrastructure first)"
	@echo "  deploy-local - Deploy with local build (faster)"
	@echo "  clean        - Clean build artifacts"

# Install dependencies
deps:
	@echo "Installing dependencies..."
{{- if .HasGRPC}}
	@echo "Checking buf..."
	@command -v buf >/dev/null 2>&1 || { \
		echo "buf is not installed. Install from https://buf.build/docs/installation"; \
		exit 1; \
	}
	@echo "✓ buf installed"
{{- end}}
{{- if .HasPostgres}}
	@echo "Checking Atlas..."
	@command -v atlas >/dev/null 2>&1 || { \
		echo "Atlas is not installed. Install from https://atlasgo.io/getting-started"; \
		exit 1; \
	}
	@echo "✓ Atlas installed"
{{- end}}
{{- if .HasDynamoDB}}
	@echo "Checking Terraform..."
	@command -v terraform >/dev/null 2>&1 || { \
		echo "Terraform is not installed. Install from https://www.terraform.io/downloads"; \
		exit 1; \
	}
	@echo "✓ Terraform installed"
{{- end}}
	@echo "✓ All dependencies installed"

{{- if .HasGRPC}}
# Generate protobuf code
generate: deps
	@echo "Generating protobuf code..."
	buf generate

{{- end}}
# Build API server
build:{{- if .HasGRPC}} generate{{- end}}
	@echo "Building API server..."
	go build -o bin/api cmd/api/main.go

# Build CLI tool
build-cli:
	@echo "Building postctl CLI..."
	go build -o bin/postctl cmd/postctl/main.go

# Install CLI tool
install-cli: build-cli
	@echo "Installing postctl to /usr/local/bin..."
	@if [ -w /usr/local/bin ]; then \
		cp bin/postctl /usr/local/bin/postctl; \
		echo "✓ Installed to /usr/local/bin/postctl"; \
	else \
		echo "Installing to /usr/local/bin (requires sudo)..."; \
		sudo cp bin/postctl /usr/local/bin/postctl; \
		echo "✓ Installed to /usr/local/bin/postctl"; \
	fi
	@echo "You can now run 'postctl' from anywhere!"

# Run API server
run:
	@echo "Running API server..."
	go run cmd/api/main.go

# Test
test:
	@echo "Running tests..."
	go test -v ./...

{{- if .HasDynamoDB}}
# Provision infrastructure with Terraform
terraform-init:
	@echo "Initializing Terraform..."
	@command -v terraform >/dev/null 2>&1 || { echo "Terraform is not installed. Install from https://www.terraform.io/downloads"; exit 1; }
	cd terraform && terraform init

terraform-plan: terraform-init
	@echo "Planning Terraform changes..."
	cd terraform && terraform plan -out=tfplan

terraform-apply: terraform-plan
	@echo "Applying Terraform changes..."
	cd terraform && terraform apply -auto-approve tfplan

terraform: terraform-apply
	@echo "✓ Infrastructure provisioned"

{{- end}}
{{- if .HasPostgres}}
# Atlas Go migration commands
# See https://atlasgo.io/ for documentation

# Check Atlas CLI is installed
atlas-check: deps
	@command -v atlas >/dev/null 2>&1 || { echo "Atlas CLI is not installed. Run 'make deps' first"; exit 1; }

# Initialize Atlas project (run once)
# Note: atlas.hcl is generated by the CLI, but migrations directory needs to be created
atlas-init: atlas-check
	@echo "Initializing Atlas migrations directory..."
	@if [ ! -d migrations ]; then \
		mkdir -p migrations; \
		echo "✓ Migrations directory created"; \
	else \
		echo "Migrations directory already exists"; \
	fi
	@echo "✓ Atlas project ready (atlas.hcl is generated by CLI)"

# Apply migrations to local database
migrate-up: atlas-check
	@echo "Applying migrations to local database..."
	@if [ ! -f atlas.hcl ]; then \
		echo "Error: Atlas project not initialized. Run 'make atlas-init' first"; \
		exit 1; \
	fi
	atlas migrate apply \
		--dir "file://migrations" \
		--url "postgres://postgres:postgres@localhost:5432/{{.ProjectName}}?sslmode=disable"
	@echo "✓ Migrations applied"

# Rollback last migration
migrate-down: atlas-check
	@echo "Rolling back last migration..."
	atlas migrate down \
		--dir "file://migrations" \
		--url "postgres://postgres:postgres@localhost:5432/{{.ProjectName}}?sslmode=disable"
	@echo "✓ Migration rolled back"

# Check migration status
migrate-status: atlas-check
	@echo "Checking migration status..."
	atlas migrate status \
		--dir "file://migrations" \
		--url "postgres://postgres:postgres@localhost:5432/{{.ProjectName}}?sslmode=disable"

# Create a new migration
migrate-new: atlas-check
	@echo "Creating new migration..."
	@if [ ! -f atlas.hcl ]; then \
		echo "Error: Atlas project not initialized. Run 'make atlas-init' first"; \
		exit 1; \
	fi
	@read -p "Enter migration name: " name; \
	atlas migrate new --dir "file://migrations" $$name
	@echo "✓ Migration created"

# Apply migrations to production
migrate-prod: atlas-check
	@echo "Applying migrations to production..."
	@if [ ! -f atlas.hcl ]; then \
		echo "Error: Atlas project not initialized. Run 'make atlas-init' first"; \
		exit 1; \
	fi
	@if [ -z "$$DATABASE_URL" ]; then \
		echo "Error: DATABASE_URL environment variable is required"; \
		exit 1; \
	fi
	atlas migrate apply \
		--dir "file://migrations" \
		--url "$$DATABASE_URL"
	@echo "✓ Migrations applied to production"

# Validate migrations
migrate-validate: atlas-check
	@echo "Validating migrations..."
	atlas migrate validate --dir "file://migrations"
	@echo "✓ Migrations are valid"

# Lint migrations
migrate-lint: atlas-check
	@echo "Linting migrations..."
	atlas migrate lint --dir "file://migrations"
	@echo "✓ Migrations linted"

# Apply migrations (default: local)
migrate: migrate-up

{{- end}}
# Deploy to Fly.io (creates app on first run)
deploy:{{- if .HasDynamoDB}} terraform{{- end}}{{- if .HasPostgres}} migrate-prod{{- end}}
	@echo "Deploying to Fly.io..."
	@if ! flyctl status >/dev/null 2>&1; then \
		echo "First deployment - creating app and deploying..."; \
		flyctl launch --copy-config --name {{.ProjectName}} --yes; \
	else \
		echo "Deploying updates..."; \
		flyctl deploy; \
	fi

# Deploy with local build (faster for development)
deploy-local:{{- if .HasDynamoDB}} terraform{{- end}}{{- if .HasPostgres}} migrate-prod{{- end}}
	@echo "Deploying to Fly.io with local build..."
	@if ! flyctl status >/dev/null 2>&1; then \
		echo "First deployment - creating app and deploying..."; \
		flyctl launch --copy-config --name {{.ProjectName}} --yes --local-only; \
	else \
		echo "Deploying updates..."; \
		flyctl deploy --local-only; \
	fi

# Clean
clean:
	@echo "Cleaning build artifacts..."
	rm -rf bin/
{{- if .HasGRPC}}
	rm -rf protos/gen/
{{- end}}

