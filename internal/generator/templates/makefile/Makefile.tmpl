.PHONY: help deps build build-cli image run test deploy deploy-local destroy{{- if .HasDynamoDB}} terraform-destroy start-dynamo stop-dynamo check-dynamo{{- end}} clean{{- if .HasGRPC}} generate{{- end}}{{- if .HasDynamoDB}} terraform terraform-init terraform-plan terraform-apply{{- end}}{{- if .HasPostgres}} atlas-init migrate migrate-up migrate-down migrate-status migrate-new migrate-prod migrate-validate migrate-lint atlas-check{{- end}}

# Default target
help:
	@echo "Available commands:"
	@echo "  deps         - Install all dependencies"
	@echo "  build        - Build the API server"
	@echo "  build-cli    - Build the postctl CLI"
	@echo "  install-cli  - Install postctl to /usr/local/bin"
	@echo "  image        - Build Docker image"
	@echo "  run          - Run the application"
	@echo "  test         - Run tests"
{{- if .HasDynamoDB}}
	@echo "  start-dynamo - Start DynamoDB Local container"
	@echo "  stop-dynamo  - Stop DynamoDB Local container"
{{- end}}
{{- if .HasGRPC}}
	@echo "  generate     - Generate code from protobuf definitions"
{{- end}}
{{- if .HasDynamoDB}}
	@echo "  terraform        - Provision infrastructure with Terraform"
	@echo "  terraform-destroy - Destroy Terraform infrastructure"
{{- end}}
{{- if .HasPostgres}}
	@echo "  atlas-init   - Initialize Atlas project (run once)"
	@echo "  migrate      - Apply migrations to local database"
	@echo "  migrate-up   - Apply migrations to local database"
	@echo "  migrate-down - Rollback last migration"
	@echo "  migrate-status - Check migration status"
	@echo "  migrate-new  - Create a new migration"
	@echo "  migrate-prod - Apply migrations to production"
	@echo "  migrate-validate - Validate migrations"
	@echo "  migrate-lint - Lint migrations"
{{- end}}
	@echo "  deploy       - Deploy to Fly.io (creates app on first run, provisions infrastructure first)"
	@echo "  deploy-local - Deploy with local build (faster)"
	@echo "  destroy      - Destroy Fly.io app (permanent, deletes all resources)"
	@echo "  clean        - Clean build artifacts"

# Install dependencies
deps:
	@echo "Installing dependencies..."
{{- if .HasGRPC}}
	@echo "Checking buf..."
	@command -v buf >/dev/null 2>&1 || { \
		echo "buf is not installed. Install from https://buf.build/docs/installation"; \
		exit 1; \
	}
	@echo "✓ buf installed"
{{- end}}
{{- if .HasPostgres}}
	@echo "Checking Atlas..."
	@command -v atlas >/dev/null 2>&1 || { \
		echo "Atlas is not installed. Install from https://atlasgo.io/getting-started"; \
		exit 1; \
	}
	@echo "✓ Atlas installed"
{{- end}}
{{- if .HasDynamoDB}}
	@echo "Checking Terraform..."
	@command -v terraform >/dev/null 2>&1 || { \
		echo "Terraform is not installed. Install from https://www.terraform.io/downloads"; \
		exit 1; \
	}
	@echo "✓ Terraform installed"
{{- end}}
	@echo "✓ All dependencies installed"

{{- if .HasGRPC}}
# Generate protobuf code
generate: deps
	@echo "Generating protobuf code..."
	@echo "Updating buf dependencies..."
	buf dep update
	@echo "Generating code from protobuf definitions..."
	buf generate

{{- end}}
# Build API server
build:{{- if .HasGRPC}} generate{{- end}}
	@echo "Building API server..."
	go build -o bin/api cmd/api/main.go

# Build CLI tool
build-cli:
	@echo "Building postctl CLI..."
	go build -o bin/postctl cmd/postctl/main.go

# Build Docker image
image:{{- if .HasGRPC}} generate{{- end}}
	@echo "Building Docker image..."
	@command -v docker >/dev/null 2>&1 || { echo "Docker is not installed. Install from https://www.docker.com/get-started"; exit 1; }
	docker build -t {{.ProjectName}}:latest .
	@echo "✓ Docker image built: {{.ProjectName}}:latest"

# Install CLI tool
install-cli: build-cli
	@echo "Installing postctl to /usr/local/bin..."
	@if [ -w /usr/local/bin ]; then \
		cp bin/postctl /usr/local/bin/postctl; \
		echo "✓ Installed to /usr/local/bin/postctl"; \
	else \
		echo "Installing to /usr/local/bin (requires sudo)..."; \
		sudo cp bin/postctl /usr/local/bin/postctl; \
		echo "✓ Installed to /usr/local/bin/postctl"; \
	fi
	@echo "You can now run 'postctl' from anywhere!"

# Run API server
run:{{- if .HasGRPC}} generate{{- end}}
	@echo "Running API server..."
	go run cmd/api/main.go

# Test
test:
	@echo "Running tests..."
	go test -v ./...

{{- if .HasDynamoDB}}
# Start DynamoDB Local
start-dynamo:
	@echo "Starting DynamoDB Local..."
	@command -v docker >/dev/null 2>&1 || { echo "Docker is not installed. Install from https://www.docker.com/get-started"; exit 1; }
	@if [ ! -f docker-compose.yml ]; then \
		echo "Error: docker-compose.yml not found"; \
		exit 1; \
	fi
	docker compose up -d dynamodb
	@echo "✓ DynamoDB Local is running on http://localhost:8000"
	@echo "  Wait a few seconds for it to be ready before running the server"

# Stop DynamoDB Local
stop-dynamo:
	@echo "Stopping DynamoDB Local..."
	@if [ -f docker-compose.yml ]; then \
		docker compose stop dynamodb; \
		echo "✓ DynamoDB Local stopped"; \
	else \
		echo "docker-compose.yml not found, skipping..."; \
	fi

# Check if DynamoDB Local is running
check-dynamo:
	@echo "Checking DynamoDB Local status..."
	@if docker ps --format '{{.Names}}' | grep -q dynamodb; then \
		echo "✓ DynamoDB Local is running"; \
	else \
		echo "✗ DynamoDB Local is not running. Run 'make start-dynamo' first"; \
		exit 1; \
	fi

# Provision infrastructure with Terraform
terraform-init:
	@echo "Initializing Terraform..."
	@command -v terraform >/dev/null 2>&1 || { echo "Terraform is not installed. Install from https://www.terraform.io/downloads"; exit 1; }
	cd terraform && terraform init

terraform-plan: terraform-init
	@echo "Planning Terraform changes..."
	cd terraform && terraform plan -out=tfplan

terraform-apply: terraform-plan
	@echo "Applying Terraform changes..."
	cd terraform && terraform apply -auto-approve tfplan

terraform: terraform-apply
	@echo "✓ Infrastructure provisioned"

# Destroy Terraform infrastructure
terraform-destroy: terraform-init
	@echo "⚠️  WARNING: This will destroy all Terraform-managed infrastructure!"
	@read -p "Are you sure you want to destroy infrastructure? (type 'yes' to confirm): " confirm; \
	if [ "$$confirm" != "yes" ]; then \
		echo "Destroy cancelled."; \
		exit 1; \
	fi
	@echo "Destroying Terraform infrastructure..."
	cd terraform && terraform destroy -auto-approve
	@echo "✓ Infrastructure destroyed"

{{- end}}
{{- if .HasPostgres}}
# Atlas Go migration commands
# See https://atlasgo.io/ for documentation

# Check Atlas CLI is installed
atlas-check: deps
	@command -v atlas >/dev/null 2>&1 || { echo "Atlas CLI is not installed. Run 'make deps' first"; exit 1; }

# Initialize Atlas project (run once)
# Note: atlas.hcl is generated by the CLI, but migrations directory needs to be created
atlas-init: atlas-check
	@echo "Initializing Atlas migrations directory..."
	@if [ ! -d migrations ]; then \
		mkdir -p migrations; \
		echo "✓ Migrations directory created"; \
	else \
		echo "Migrations directory already exists"; \
	fi
	@echo "✓ Atlas project ready (atlas.hcl is generated by CLI)"

# Apply migrations to local database
migrate-up: atlas-check
	@echo "Applying migrations to local database..."
	@if [ ! -f atlas.hcl ]; then \
		echo "Error: Atlas project not initialized. Run 'make atlas-init' first"; \
		exit 1; \
	fi
	atlas migrate apply \
		--dir "file://migrations" \
		--url "postgres://postgres:postgres@localhost:5432/{{.ProjectName}}?sslmode=disable"
	@echo "✓ Migrations applied"

# Rollback last migration
migrate-down: atlas-check
	@echo "Rolling back last migration..."
	atlas migrate down \
		--dir "file://migrations" \
		--url "postgres://postgres:postgres@localhost:5432/{{.ProjectName}}?sslmode=disable"
	@echo "✓ Migration rolled back"

# Check migration status
migrate-status: atlas-check
	@echo "Checking migration status..."
	atlas migrate status \
		--dir "file://migrations" \
		--url "postgres://postgres:postgres@localhost:5432/{{.ProjectName}}?sslmode=disable"

# Create a new migration
migrate-new: atlas-check
	@echo "Creating new migration..."
	@if [ ! -f atlas.hcl ]; then \
		echo "Error: Atlas project not initialized. Run 'make atlas-init' first"; \
		exit 1; \
	fi
	@read -p "Enter migration name: " name; \
	atlas migrate new --dir "file://migrations" $$name
	@echo "✓ Migration created"

# Apply migrations to production
migrate-prod: atlas-check
	@echo "Applying migrations to production..."
	@if [ ! -f atlas.hcl ]; then \
		echo "Error: Atlas project not initialized. Run 'make atlas-init' first"; \
		exit 1; \
	fi
	@if [ -z "$$DATABASE_URL" ]; then \
		echo "Error: DATABASE_URL environment variable is required"; \
		exit 1; \
	fi
	atlas migrate apply \
		--dir "file://migrations" \
		--url "$$DATABASE_URL"
	@echo "✓ Migrations applied to production"

# Validate migrations
migrate-validate: atlas-check
	@echo "Validating migrations..."
	atlas migrate validate --dir "file://migrations"
	@echo "✓ Migrations are valid"

# Lint migrations
migrate-lint: atlas-check
	@echo "Linting migrations..."
	atlas migrate lint --dir "file://migrations"
	@echo "✓ Migrations linted"

# Apply migrations (default: local)
migrate: migrate-up

{{- end}}
# Deploy to Fly.io (creates app on first run)
deploy:{{- if .HasDynamoDB}} terraform{{- end}}{{- if .HasPostgres}} migrate-prod{{- end}}
	@echo "Deploying to Fly.io..."
	@if ! flyctl status >/dev/null 2>&1; then \
		echo "First deployment - creating app and deploying..."; \
		flyctl launch --copy-config --name {{.ProjectName}} --yes; \
	else \
		echo "Deploying updates..."; \
		flyctl deploy; \
	fi

# Deploy with local build (faster for development)
deploy-local:{{- if .HasDynamoDB}} terraform{{- end}}{{- if .HasPostgres}} migrate-prod{{- end}}
	@echo "Deploying to Fly.io with local build..."
	@if ! flyctl status >/dev/null 2>&1; then \
		echo "First deployment - creating app and deploying..."; \
		flyctl launch --copy-config --name {{.ProjectName}} --yes --local-only; \
	else \
		echo "Deploying updates..."; \
		flyctl deploy --local-only; \
	fi

# Destroy Fly.io app and infrastructure (permanent - deletes app and all resources)
destroy:{{- if .HasDynamoDB}} terraform-destroy{{- end}}
	@echo "⚠️  WARNING: This will permanently delete the Fly.io app '{{.ProjectName}}' and all associated resources!"
	@echo "This action cannot be undone."
	@read -p "Are you sure you want to continue? (type 'yes' to confirm): " confirm; \
	if [ "$$confirm" != "yes" ]; then \
		echo "Destroy cancelled."; \
		exit 1; \
	fi
	@echo "Destroying Fly.io app..."
	@if command -v flyctl >/dev/null 2>&1; then \
		flyctl apps destroy {{.ProjectName}} --yes; \
	elif command -v fly >/dev/null 2>&1; then \
		fly apps destroy {{.ProjectName}} --yes; \
	else \
		echo "Error: flyctl or fly command not found. Install from https://fly.io/docs/getting-started/installing-flyctl/"; \
		exit 1; \
	fi
	@echo "✓ App destroyed"

# Clean
clean:
	@echo "Cleaning build artifacts..."
	rm -rf bin/
{{- if .HasGRPC}}
	rm -rf protos/gen/
{{- end}}

