package posts

import (
	"context"
	"fmt"
	"log/slog"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/google/uuid"
)

const (
	TableName = "{{.ProjectName}}-posts"
	SlugIndex = "SlugIndex"
)

// Table is a repository for DynamoDB operations on posts
type Table struct {
	client *dynamodb.Client
}

// NewTable creates a new posts table repository and tests the connection
// by describing the table to fail fast if the connection fails
func NewTable(ctx context.Context, client *dynamodb.Client) (*Table, error) {
	// Test connection by describing the table - fail fast if connection fails
	_, err := client.DescribeTable(ctx, &dynamodb.DescribeTableInput{
		TableName: aws.String(TableName),
	})
	if err != nil {
		slog.ErrorContext(ctx, "Table: failed to connect to DynamoDB table", "error", err, "table_name", TableName)
		return nil, fmt.Errorf("failed to connect to DynamoDB table %s: %w", TableName, err)
	}

	return &Table{
		client: client,
	}, nil
}

// Put saves a post to DynamoDB
func (t *Table) Put(ctx context.Context, post *Post) error {
	item, err := attributevalue.MarshalMap(post)
	if err != nil {
		slog.ErrorContext(ctx, "Table: failed to marshal post", "error", err, "post_id", post.ID, "user_id", post.UserID)
		return fmt.Errorf("failed to marshal post: %w", err)
	}

	_, err = t.client.PutItem(ctx, &dynamodb.PutItemInput{
		TableName: aws.String(TableName),
		Item:      item,
	})
	if err != nil {
		slog.ErrorContext(ctx, "Table: failed to put post", "error", err, "post_id", post.ID, "user_id", post.UserID, "table_name", TableName)
		return fmt.Errorf("failed to put post: %w", err)
	}

	return nil
}

// Get retrieves a post by UserID and PostID (primary key)
func (t *Table) Get(ctx context.Context, userID, postID uuid.UUID) (*Post, error) {
	result, err := t.client.GetItem(ctx, &dynamodb.GetItemInput{
		TableName: aws.String(TableName),
		Key: map[string]types.AttributeValue{
			"UserID": &types.AttributeValueMemberS{Value: userID.String()},
			"PostID": &types.AttributeValueMemberS{Value: postID.String()},
		},
	})
	if err != nil {
		slog.ErrorContext(ctx, "Table: failed to get post", "error", err, "user_id", userID, "post_id", postID, "table_name", TableName)
		return nil, fmt.Errorf("failed to get post: %w", err)
	}

	if result.Item == nil {
		return nil, nil
	}

	var post Post
	if err := attributevalue.UnmarshalMap(result.Item, &post); err != nil {
		slog.ErrorContext(ctx, "Table: failed to unmarshal post", "error", err, "user_id", userID, "post_id", postID)
		return nil, fmt.Errorf("failed to unmarshal post: %w", err)
	}

	return &post, nil
}

// GetBySlug retrieves a post by its slug using GSI
func (t *Table) GetBySlug(ctx context.Context, slug uuid.UUID) (*Post, error) {
	result, err := t.client.Query(ctx, &dynamodb.QueryInput{
		TableName:              aws.String(TableName),
		IndexName:              aws.String(SlugIndex),
		KeyConditionExpression: aws.String("Slug = :slug"),
		ExpressionAttributeValues: map[string]types.AttributeValue{
			":slug": &types.AttributeValueMemberS{Value: slug.String()},
		},
	})
	if err != nil {
		slog.ErrorContext(ctx, "Table: failed to query post by slug", "error", err, "slug", slug, "table_name", TableName, "index_name", SlugIndex)
		return nil, fmt.Errorf("failed to query post by slug: %w", err)
	}

	if len(result.Items) == 0 {
		return nil, nil
	}

	var post Post
	if err := attributevalue.UnmarshalMap(result.Items[0], &post); err != nil {
		slog.ErrorContext(ctx, "Table: failed to unmarshal post", "error", err, "slug", slug)
		return nil, fmt.Errorf("failed to unmarshal post: %w", err)
	}

	return &post, nil
}

// ListByUser retrieves all posts for a user
func (t *Table) ListByUser(ctx context.Context, userID uuid.UUID) ([]*Post, error) {
	result, err := t.client.Query(ctx, &dynamodb.QueryInput{
		TableName:              aws.String(TableName),
		KeyConditionExpression: aws.String("UserID = :userID"),
		ExpressionAttributeValues: map[string]types.AttributeValue{
			":userID": &types.AttributeValueMemberS{Value: userID.String()},
		},
	})
	if err != nil {
		slog.ErrorContext(ctx, "Table: failed to query posts", "error", err, "user_id", userID, "table_name", TableName)
		return nil, fmt.Errorf("failed to query posts: %w", err)
	}

	posts := make([]*Post, 0, len(result.Items))
	for _, item := range result.Items {
		var post Post
		if err := attributevalue.UnmarshalMap(item, &post); err != nil {
			slog.ErrorContext(ctx, "Table: failed to unmarshal post in list", "error", err, "user_id", userID)
			return nil, fmt.Errorf("failed to unmarshal post: %w", err)
		}
		posts = append(posts, &post)
	}

	return posts, nil
}

// Delete removes a post from DynamoDB
func (t *Table) Delete(ctx context.Context, userID, postID uuid.UUID) error {
	_, err := t.client.DeleteItem(ctx, &dynamodb.DeleteItemInput{
		TableName: aws.String(TableName),
		Key: map[string]types.AttributeValue{
			"UserID": &types.AttributeValueMemberS{Value: userID.String()},
			"PostID": &types.AttributeValueMemberS{Value: postID.String()},
		},
	})
	if err != nil {
		slog.ErrorContext(ctx, "Table: failed to delete post", "error", err, "user_id", userID, "post_id", postID, "table_name", TableName)
		return fmt.Errorf("failed to delete post: %w", err)
	}

	return nil
}

