package posts

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/credentials"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/wait"
)

const (
	// dynamoDBContainerPort is the internal container port that DynamoDB Local listens on
	// testcontainers automatically maps this to a random host port to avoid contention
	dynamoDBContainerPort = "8000/tcp"
)

func setupTestDynamoDB(t *testing.T) (*dynamodb.Client, string, func()) {
	ctx := context.Background()

	// Start DynamoDB Local container (official AWS tool - lighter and faster than LocalStack)
	// testcontainers automatically assigns random host ports when ExposedPorts is specified
	// This avoids port contention when running tests in parallel
	req := testcontainers.ContainerRequest{
		Image:        "amazon/dynamodb-local:latest",
		ExposedPorts: []string{dynamoDBContainerPort},
		Cmd:          []string{"-jar", "DynamoDBLocal.jar", "-sharedDb", "-inMemory"},
		// Wait for container to be ready - DynamoDB Local starts quickly but may need time to initialize
		// Use a generous timeout to account for slower systems, Docker daemon delays, network issues, etc.
		// Wait for the port to be listening, which indicates DynamoDB Local is ready
		// Use the constant instead of hardcoding the port
		WaitingFor: wait.ForListeningPort(dynamoDBContainerPort).
			WithStartupTimeout(60 * time.Second).
			WithPollInterval(100 * time.Millisecond),
	}
	
	dynamoContainer, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
		ContainerRequest: req,
		Started:          true,
	})
	require.NoError(t, err)

	// Get endpoint with random port assignment (testcontainers automatically assigns random host port)
	// This avoids port contention when running tests in parallel
	// Endpoint() returns "host:port" format, so we need to prepend "http://" for DynamoDB Local
	endpoint, err := dynamoContainer.Endpoint(ctx, "")
	require.NoError(t, err)
	endpointURL := fmt.Sprintf("http://%s", endpoint)

	// Create DynamoDB client
	cfg, err := config.LoadDefaultConfig(ctx,
		config.WithRegion("us-east-1"),
		config.WithCredentialsProvider(credentials.NewStaticCredentialsProvider("test", "test", "")),
		config.WithEndpointResolverWithOptions(aws.EndpointResolverWithOptionsFunc(
			func(service, region string, options ...interface{}) (aws.Endpoint, error) {
				return aws.Endpoint{
					URL:           endpointURL,
					SigningRegion: "us-east-1",
				}, nil
			})),
	)
	require.NoError(t, err)

	client := dynamodb.NewFromConfig(cfg)

	// Create table
	tableName := "test-posts"
	_, err = client.CreateTable(ctx, &dynamodb.CreateTableInput{
		TableName: aws.String(tableName),
		AttributeDefinitions: []types.AttributeDefinition{
			{
				AttributeName: aws.String("UserID"),
				AttributeType: types.ScalarAttributeTypeS,
			},
			{
				AttributeName: aws.String("CreatedAt"),
				AttributeType: types.ScalarAttributeTypeN,
			},
			{
				AttributeName: aws.String("PostID"),
				AttributeType: types.ScalarAttributeTypeS,
			},
		},
		KeySchema: []types.KeySchemaElement{
			{
				AttributeName: aws.String("UserID"),
				KeyType:       types.KeyTypeHash,
			},
			{
				AttributeName: aws.String("CreatedAt"),
				KeyType:       types.KeyTypeRange,
			},
		},
		GlobalSecondaryIndexes: []types.GlobalSecondaryIndex{
			{
				IndexName: aws.String("PostIDIndex"),
				KeySchema: []types.KeySchemaElement{
					{
						AttributeName: aws.String("PostID"),
						KeyType:       types.KeyTypeHash,
					},
				},
				Projection: &types.Projection{
					ProjectionType: types.ProjectionTypeAll,
				},
			},
		},
		BillingMode: types.BillingModePayPerRequest,
	})
	require.NoError(t, err)

	// Wait for table to be active
	waiter := dynamodb.NewTableExistsWaiter(client)
	err = waiter.Wait(ctx, &dynamodb.DescribeTableInput{
		TableName: aws.String(tableName),
	}, 30*time.Second)
	require.NoError(t, err)

	// Cleanup function
	cleanup := func() {
		_, _ = client.DeleteTable(ctx, &dynamodb.DeleteTableInput{
			TableName: aws.String(tableName),
		})
		require.NoError(t, dynamoContainer.Terminate(ctx))
	}

	return client, tableName, cleanup
}

func TestPostStorageModel(t *testing.T) {
	t.Parallel()

	post := &Post{
		ID:        uuid.MustParse("123e4567-e89b-12d3-a456-426614174000"),
		UserID:    uuid.MustParse("223e4567-e89b-12d3-a456-426614174001"),
		Title:     "Test Post",
		Content:   "Test Content",
		CreatedAt: time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC),
		UpdatedAt: time.Date(2024, 1, 2, 12, 0, 0, 0, time.UTC),
	}

	// Convert Post to PostStorageModel
	storage := PostToStorage(post)

	// Marshal PostStorageModel directly to DynamoDB item using dynamodbav tags
	item, err := attributevalue.MarshalMap(storage)
	require.NoError(t, err)
	require.NotNil(t, item)

	// Verify UUID fields are stored as strings
	userIDVal, ok := item["UserID"].(*types.AttributeValueMemberS)
	require.True(t, ok, "UserID should be a string")
	assert.Equal(t, post.UserID.String(), userIDVal.Value)

	postIDVal, ok := item["PostID"].(*types.AttributeValueMemberS)
	require.True(t, ok, "PostID should be a string")
	assert.Equal(t, post.ID.String(), postIDVal.Value)

	// Verify CreatedAt is stored as epoch millis (number)
	createdAtVal, ok := item["CreatedAt"].(*types.AttributeValueMemberN)
	require.True(t, ok, "CreatedAt should be a number")
	assert.Equal(t, fmt.Sprintf("%d", post.CreatedAt.UnixMilli()), createdAtVal.Value)

	// Verify UpdatedAt is stored as epoch millis (number)
	updatedAtVal, ok := item["UpdatedAt"].(*types.AttributeValueMemberN)
	require.True(t, ok, "UpdatedAt should be a number")
	assert.Equal(t, fmt.Sprintf("%d", post.UpdatedAt.UnixMilli()), updatedAtVal.Value)

	// Verify string fields
	titleVal, ok := item["Title"].(*types.AttributeValueMemberS)
	require.True(t, ok, "Title should be a string")
	assert.Equal(t, post.Title, titleVal.Value)

	contentVal, ok := item["Content"].(*types.AttributeValueMemberS)
	require.True(t, ok, "Content should be a string")
	assert.Equal(t, post.Content, contentVal.Value)

	// Test round-trip: unmarshal back to PostStorageModel
	var unmarshaled PostStorageModel
	err = attributevalue.UnmarshalMap(item, &unmarshaled)
	require.NoError(t, err)
	assert.Equal(t, storage.UserID, unmarshaled.UserID)
	assert.Equal(t, storage.PostID, unmarshaled.PostID)
	assert.Equal(t, storage.CreatedAt, unmarshaled.CreatedAt)
	assert.Equal(t, storage.Title, unmarshaled.Title)
	assert.Equal(t, storage.Content, unmarshaled.Content)
	assert.Equal(t, storage.UpdatedAt, unmarshaled.UpdatedAt)
}

func TestPostTable_PutPost(t *testing.T) {
	t.Parallel()
	client, tableName, cleanup := setupTestDynamoDB(t)
	defer cleanup()

	ctx := context.Background()
	table, err := NewPostTable(ctx, client, tableName)
	require.NoError(t, err)

	post := &Post{
		ID:        uuid.New(),
		UserID:    uuid.New(),
		Title:     "Test Post",
		Content:   "Test Content",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	err = table.PutPost(ctx, post)
	assert.NoError(t, err)

	// Verify post was inserted by getting it by ID
	retrieved, err := table.GetPostByID(ctx, post.ID)
	require.NoError(t, err)
	assert.Equal(t, post.ID, retrieved.ID)
}

func TestPostTable_GetPostByID(t *testing.T) {
	t.Parallel()
	client, tableName, cleanup := setupTestDynamoDB(t)
	defer cleanup()

	ctx := context.Background()
	table, err := NewPostTable(ctx, client, tableName)
	require.NoError(t, err)

	post := &Post{
		ID:        uuid.New(),
		UserID:    uuid.New(),
		Title:     "Test Post",
		Content:   "Test Content",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	err = table.PutPost(ctx, post)
	require.NoError(t, err)

	// Get post by ID
	retrieved, err := table.GetPostByID(ctx, post.ID)
	require.NoError(t, err)
	assert.Equal(t, post.ID, retrieved.ID)
	assert.Equal(t, post.UserID, retrieved.UserID)
	assert.Equal(t, post.Title, retrieved.Title)
	assert.Equal(t, post.Content, retrieved.Content)

	// Test not found
	_, err = table.GetPostByID(ctx, uuid.New())
	assert.ErrorIs(t, err, ErrPostNotFound)
}

func TestPostTable_ListPostsByUserID(t *testing.T) {
	t.Parallel()
	client, tableName, cleanup := setupTestDynamoDB(t)
	defer cleanup()

	ctx := context.Background()
	table, err := NewPostTable(ctx, client, tableName)
	require.NoError(t, err)

	userID := uuid.New()
	otherUserID := uuid.New()

	// Create posts for user
	post1 := &Post{
		ID:        uuid.New(),
		UserID:    userID,
		Title:     "Post 1",
		Content:   "Content 1",
		CreatedAt: time.Now().Add(-2 * time.Hour),
		UpdatedAt: time.Now().Add(-2 * time.Hour),
	}
	post2 := &Post{
		ID:        uuid.New(),
		UserID:    userID,
		Title:     "Post 2",
		Content:   "Content 2",
		CreatedAt: time.Now().Add(-1 * time.Hour),
		UpdatedAt: time.Now().Add(-1 * time.Hour),
	}
	// Post for different user
	post3 := &Post{
		ID:        uuid.New(),
		UserID:    otherUserID,
		Title:     "Post 3",
		Content:   "Content 3",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	err = table.PutPost(ctx, post1)
	require.NoError(t, err)
	err = table.PutPost(ctx, post2)
	require.NoError(t, err)
	err = table.PutPost(ctx, post3)
	require.NoError(t, err)

	// List posts for user
	posts, err := table.ListPostsByUserID(ctx, userID)
	require.NoError(t, err)
	assert.Len(t, posts, 2)

	// List posts for other user
	posts, err = table.ListPostsByUserID(ctx, otherUserID)
	require.NoError(t, err)
	assert.Len(t, posts, 1)
	assert.Equal(t, post3.ID, posts[0].ID)
}

func TestPostTable_DeletePost(t *testing.T) {
	t.Parallel()
	client, tableName, cleanup := setupTestDynamoDB(t)
	defer cleanup()

	ctx := context.Background()
	table, err := NewPostTable(ctx, client, tableName)
	require.NoError(t, err)

	post := &Post{
		ID:        uuid.New(),
		UserID:    uuid.New(),
		Title:     "Test Post",
		Content:   "Test Content",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	err = table.PutPost(ctx, post)
	require.NoError(t, err)

	// Delete post
	err = table.DeletePost(ctx, post.ID)
	assert.NoError(t, err)

	// Verify post was deleted
	_, err = table.GetPostByID(ctx, post.ID)
	assert.ErrorIs(t, err, ErrPostNotFound)
}

func TestPostTable_UpdatePost(t *testing.T) {
	t.Parallel()
	client, tableName, cleanup := setupTestDynamoDB(t)
	defer cleanup()

	ctx := context.Background()
	table, err := NewPostTable(ctx, client, tableName)
	require.NoError(t, err)

	post := &Post{
		ID:        uuid.New(),
		UserID:    uuid.New(),
		Title:     "Original Title",
		Content:   "Original Content",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	err = table.PutPost(ctx, post)
	require.NoError(t, err)

	// Update post
	post.Title = "Updated Title"
	post.Content = "Updated Content"
	post.UpdatedAt = time.Now()

	err = table.PutPost(ctx, post)
	require.NoError(t, err)

	// Verify post was updated
	retrieved, err := table.GetPostByID(ctx, post.ID)
	require.NoError(t, err)
	assert.Equal(t, "Updated Title", retrieved.Title)
	assert.Equal(t, "Updated Content", retrieved.Content)
}

