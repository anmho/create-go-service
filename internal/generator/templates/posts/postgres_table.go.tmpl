package posts

import (
	"context"
	"fmt"
	"log/slog"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

// PostTable implements Table for PostgreSQL
type PostTable struct {
	pool *pgxpool.Pool
}

// NewPostTable creates a new PostgreSQL repository for posts and tests the connection
// by pinging the database to fail fast if the connection fails
func NewPostTable(ctx context.Context, pool *pgxpool.Pool) (*PostTable, error) {
	// Test connection by pinging the database - fail fast if connection fails
	if err := pool.Ping(ctx); err != nil {
		return nil, fmt.Errorf("failed to connect to PostgreSQL: %w", err)
	}

	return &PostTable{
		pool: pool,
	}, nil
}

// PutPost saves a post to PostgreSQL
func (t *PostTable) PutPost(ctx context.Context, post *Post) error {
	query := `
		INSERT INTO posts (id, user_id, slug, title, content, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7)
		ON CONFLICT (id) DO UPDATE SET
			title = EXCLUDED.title,
			content = EXCLUDED.content,
			updated_at = EXCLUDED.updated_at
	`
	_, err := t.pool.Exec(ctx, query,
		post.ID,
		post.UserID,
		post.Slug,
		post.Title,
		post.Content,
		post.CreatedAt,
		post.UpdatedAt,
	)
	if err != nil {
		slog.ErrorContext(ctx, "Table: failed to put post", "error", err, "post_id", post.ID, "user_id", post.UserID)
		return fmt.Errorf("failed to put post: %w", err)
	}

	return nil
}

// GetPostByID retrieves a post by its ID
func (t *PostTable) GetPostByID(ctx context.Context, postID uuid.UUID) (*Post, error) {
	query := `
		SELECT id, user_id, slug, title, content, created_at, updated_at
		FROM posts
		WHERE id = $1
	`

	rows, err := t.pool.Query(ctx, query, postID)
	if err != nil {
		slog.ErrorContext(ctx, "Table: failed to query post", "error", err, "post_id", postID)
		return nil, fmt.Errorf("failed to query post: %w", err)
	}
	defer rows.Close()

	post, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[Post])
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrPostNotFound
		}
		slog.ErrorContext(ctx, "Table: failed to get post by ID", "error", err, "post_id", postID)
		return nil, fmt.Errorf("failed to get post by ID: %w", err)
	}

	return &post, nil
}

// GetPostBySlug retrieves a post by its slug
func (t *PostTable) GetPostBySlug(ctx context.Context, slug uuid.UUID) (*Post, error) {
	query := `
		SELECT id, user_id, slug, title, content, created_at, updated_at
		FROM posts
		WHERE slug = $1
	`

	rows, err := t.pool.Query(ctx, query, slug)
	if err != nil {
		slog.ErrorContext(ctx, "Table: failed to query post", "error", err, "slug", slug)
		return nil, fmt.Errorf("failed to query post: %w", err)
	}
	defer rows.Close()

	post, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[Post])
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, ErrPostNotFound
		}
		slog.ErrorContext(ctx, "Table: failed to get post by slug", "error", err, "slug", slug)
		return nil, fmt.Errorf("failed to get post by slug: %w", err)
	}

	return &post, nil
}

// ListPostsByUserID retrieves all posts for a user
func (t *PostTable) ListPostsByUserID(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	query := `
		SELECT id, user_id, slug, title, content, created_at, updated_at
		FROM posts
		WHERE user_id = $1
		ORDER BY created_at DESC
	`

	rows, err := t.pool.Query(ctx, query, userID)
	if err != nil {
		slog.ErrorContext(ctx, "Table: failed to query posts", "error", err, "user_id", userID)
		return nil, fmt.Errorf("failed to query posts: %w", err)
	}
	defer rows.Close()

	posts, err := pgx.CollectRows(rows, pgx.RowToStructByName[Post])
	if err != nil {
		slog.ErrorContext(ctx, "Table: failed to scan posts", "error", err, "user_id", userID)
		return nil, fmt.Errorf("failed to scan posts: %w", err)
	}

	return posts, nil
}

// DeletePost removes a post from PostgreSQL by ID
func (t *PostTable) DeletePost(ctx context.Context, postID uuid.UUID) error {
	query := `
		DELETE FROM posts
		WHERE id = $1
	`

	result, err := t.pool.Exec(ctx, query, postID)
	if err != nil {
		slog.ErrorContext(ctx, "Table: failed to delete post", "error", err, "post_id", postID)
		return fmt.Errorf("failed to delete post: %w", err)
	}

	if result.RowsAffected() == 0 {
		return ErrPostNotFound
	}

	return nil
}

