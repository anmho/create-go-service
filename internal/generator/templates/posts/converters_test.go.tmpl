package posts

import (
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
{{- if .HasGRPC}}
	"google.golang.org/protobuf/types/known/timestamppb"
	postsv1 "{{.ModulePath}}/protos/gen/posts/v1"
{{- end}}
)

{{- if .HasGRPC}}
func TestPostToProto(t *testing.T) {
	t.Parallel()

	post := &Post{
		ID:        uuid.MustParse("123e4567-e89b-12d3-a456-426614174000"),
		UserID:    uuid.MustParse("223e4567-e89b-12d3-a456-426614174001"),
		Title:     "Test Post",
		Content:   "Test Content",
		CreatedAt: time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC),
		UpdatedAt: time.Date(2024, 1, 2, 12, 0, 0, 0, time.UTC),
	}

	proto := PostToProto(post)

	assert.Equal(t, post.ID.String(), proto.Id)
	assert.Equal(t, post.UserID.String(), proto.UserId)
	assert.Equal(t, post.Title, proto.Title)
	assert.Equal(t, post.Content, proto.Content)
	assert.True(t, proto.CreatedAt.AsTime().Equal(post.CreatedAt))
	assert.True(t, proto.UpdatedAt.AsTime().Equal(post.UpdatedAt))
}

func TestProtoToPost(t *testing.T) {
	t.Parallel()

	proto := &postsv1.Post{
		Id:        "123e4567-e89b-12d3-a456-426614174000",
		UserId:    "223e4567-e89b-12d3-a456-426614174001",
		Title:     "Test Post",
		Content:   "Test Content",
		CreatedAt: timestamppb.New(time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC)),
		UpdatedAt: timestamppb.New(time.Date(2024, 1, 2, 12, 0, 0, 0, time.UTC)),
	}

	post, err := ProtoToPost(proto)
	require.NoError(t, err)

	assert.Equal(t, proto.Id, post.ID.String())
	assert.Equal(t, proto.UserId, post.UserID.String())
	assert.Equal(t, proto.Title, post.Title)
	assert.Equal(t, proto.Content, post.Content)
	assert.True(t, proto.CreatedAt.AsTime().Equal(post.CreatedAt))
	assert.True(t, proto.UpdatedAt.AsTime().Equal(post.UpdatedAt))
}

func TestProtoToPost_InvalidUUID(t *testing.T) {
	t.Parallel()

	proto := &postsv1.Post{
		Id:        "invalid-uuid",
		UserId:    "223e4567-e89b-12d3-a456-426614174001",
		Title:     "Test Post",
		Content:   "Test Content",
		CreatedAt: timestamppb.New(time.Now()),
		UpdatedAt: timestamppb.New(time.Now()),
	}

	_, err := ProtoToPost(proto)
	assert.Error(t, err)
}

func TestPostToProto_RoundTrip(t *testing.T) {
	t.Parallel()

	original := &Post{
		ID:        uuid.New(),
		UserID:    uuid.New(),
		Title:     "Test Post",
		Content:   "Test Content",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	proto := PostToProto(original)
	converted, err := ProtoToPost(proto)
	require.NoError(t, err)

	assert.Equal(t, original.ID, converted.ID)
	assert.Equal(t, original.UserID, converted.UserID)
	assert.Equal(t, original.Title, converted.Title)
	assert.Equal(t, original.Content, converted.Content)
	assert.True(t, original.CreatedAt.Equal(converted.CreatedAt))
	assert.True(t, original.UpdatedAt.Equal(converted.UpdatedAt))
}
{{- end}}

func TestPostToStorage(t *testing.T) {
	t.Parallel()

	post := &Post{
		ID:        uuid.MustParse("123e4567-e89b-12d3-a456-426614174000"),
		UserID:    uuid.MustParse("223e4567-e89b-12d3-a456-426614174001"),
		Title:     "Test Post",
		Content:   "Test Content",
		CreatedAt: time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC),
		UpdatedAt: time.Date(2024, 1, 2, 12, 0, 0, 0, time.UTC),
	}

	storage := PostToStorage(post)

	assert.Equal(t, post.UserID.String(), storage.UserID)
	assert.Equal(t, post.ID.String(), storage.PostID)
	assert.Equal(t, post.CreatedAt.UnixMilli(), storage.CreatedAt)
	assert.Equal(t, post.Title, storage.Title)
	assert.Equal(t, post.Content, storage.Content)
	assert.Equal(t, post.UpdatedAt.UnixMilli(), storage.UpdatedAt)
}

func TestStorageToPost(t *testing.T) {
	t.Parallel()

	storage := &PostStorageModel{
		UserID:    "223e4567-e89b-12d3-a456-426614174001",
		PostID:    "123e4567-e89b-12d3-a456-426614174000",
		CreatedAt: time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC).UnixMilli(),
		Title:     "Test Post",
		Content:   "Test Content",
		UpdatedAt: time.Date(2024, 1, 2, 12, 0, 0, 0, time.UTC).UnixMilli(),
	}

	post, err := StorageToPost(storage)
	require.NoError(t, err)

	assert.Equal(t, storage.UserID, post.UserID.String())
	assert.Equal(t, storage.PostID, post.ID.String())
	assert.True(t, time.UnixMilli(storage.CreatedAt).Equal(post.CreatedAt))
	assert.Equal(t, storage.Title, post.Title)
	assert.Equal(t, storage.Content, post.Content)
	assert.True(t, time.UnixMilli(storage.UpdatedAt).Equal(post.UpdatedAt))
}

func TestStorageToPost_InvalidUUID(t *testing.T) {
	t.Parallel()

	storage := &PostStorageModel{
		UserID:    "invalid-uuid",
		PostID:    "123e4567-e89b-12d3-a456-426614174000",
		CreatedAt: time.Now().UnixMilli(),
		Title:     "Test Post",
		Content:   "Test Content",
		UpdatedAt: time.Now().UnixMilli(),
	}

	_, err := StorageToPost(storage)
	assert.Error(t, err)
}

func TestPostToStorage_RoundTrip(t *testing.T) {
	t.Parallel()

	// Use fixed timestamps truncated to milliseconds to avoid precision loss
	// When converting through Unix milliseconds, sub-millisecond precision is lost
	fixedTime := time.Date(2024, 1, 15, 12, 30, 45, 123000000, time.UTC).Truncate(time.Millisecond)

	original := &Post{
		ID:        uuid.New(),
		UserID:    uuid.New(),
		Title:     "Test Post",
		Content:   "Test Content",
		CreatedAt: fixedTime,
		UpdatedAt: fixedTime,
	}

	storage := PostToStorage(original)
	converted, err := StorageToPost(storage)
	require.NoError(t, err)

	assert.Equal(t, original.ID, converted.ID)
	assert.Equal(t, original.UserID, converted.UserID)
	assert.Equal(t, original.Title, converted.Title)
	assert.Equal(t, original.Content, converted.Content)
	// Timestamps should match exactly when using fixed time truncated to milliseconds
	assert.True(t, original.CreatedAt.Equal(converted.CreatedAt))
	assert.True(t, original.UpdatedAt.Equal(converted.UpdatedAt))
}

